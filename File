

//между вьюдидлоад и вьювилэпир высчитываются кострейны ВАЖНЫЙ ВОПРОС)
//вьюдид эпир - срабатывает когда вью появлявилась на экране
//вью вилдезапир - срабатывает перед тем как экран уходит
//вьюдидДезапир - когда экран ушел
//viewDidUnload -
//большой круг срабатывает, когда мы ушли с экрана
//Память работает через референс каунт, а не через гербежколлектор; ARC - automaticRefenceCount
//retainCycle - прочитать, два объекта ссылаются друг на друга и висят в памяти, хотя на них нет ссылок



//Таблицы
// таблица стиля плей - хедер и футер не уезжают / плейн - скролятся, как обычные строки
// table.view.rowHeight = UITableViewAutomaticDimension - считает автоматически, table.view.estimatedRowHeight = 44 - для автоматического расчета высоты ячеек приблизительное значение
// метод таблевью естимейтХайтФоРоуАт - говорит какой высоты должна быть ячейка

Лекция 5

пир - одноранговый участник сети (участники равноправные)
Multipeer Connectivity Framework (wifi, blootuth, peer to peer wifi)

фазы:
1 обнаружение пользователей
2 обмен данными

обнаруживаем MCPeerID - всегда уникальный независим от времнеи
init(display Name:)

Браузер(ищет) и адвератайзер(тот кого ищат)
есть делегаты с методами старт/стоп

Адвертайзер передаем пирАйди(созданный нами)
дискаверИнфо - словарь на 400 байт - будет передаваться, когда браузер находит пир (можно передать имя цвет текста, ссылку на фотку и тд)
сервисТайп - название сервеса в котором будет работать браузер и адвертайзер (тинькоффЧат) 15 символ и др ограничения

делегат может сказать, что адвертайзер не смог стартовать,
что адвер получил приглашение от браузера (с перАйди от другого пользователя, дата, Инвинтейшенхендлер блок в блок передаем сессию в которую принемаем приглашение или нет)


Браузер
Приглашака инвайтПир(таймаут, дата и ...), инит
делегат говорит, браузер не смог, нашел пира(фаунд пир), потерял (лост пир)

БраузерВьюКонтроллер (нам не оч подходит)

СервисАдвайтайзерАсистант - показывает алерт с принятием и отказом (нам не надо)

2 фаза Сессия появляется, когда создаем с чуваком канал (сессия следит за стадом пиров - максимум 8 человек)
при привышения числа 8, создаем несколько сессий (будем делать по два человека в сесси)
Сессия контейнер для пир айдишек

Инициализация сесси
1 передаем нашу айдишку
2 секьюритиАйдентити передаем сертификаты - нам не надо пока, экрипшениПреференс - вид шифрование

передача данных в сессии сенда(дата, ту пир, с модом(рилайбл - в очередь все сообщения, анринайлб - в каком порядке дайдут сообщения, в таком дайдут дайдут)) - будем использовать пока этот метод передавать жесон
стартСтрим - начинает поток
сендСурсу - передает файл

прием данных - отвечает делегат

делегатныйметод приконектился пир или не приконнектился



Лекция 7 Core Data

NSPersistentStore - хранилище для координатора
    Класы для наследования для кастомного хранилища
    NSAtomicStore - все хранилище будет считано в память за один раз (NSBynaryStoreType) - для маленьких объемов
    NSIncrementalStore - можно читать по кусочкам (NSSQLiteStoreType)

NSManagedObjectModel - содержит схему описывающую сущности
    Хранит сущности, шаблоны запросов
    Optional - может не быть, Transient - не будет записан в БД

    FethLimit - сколько хотим получить

NSPresistentCoordinator - общается с моделью и с хранилищем

NSManagedObjectContext - содержит объекты, сохраняет, достает, отслеживает изменения

    Типы контекстов privateQueuConcurrencyType; mainQueueConcurrencyType - будут выполнять блоки в главном и не главном потоках

любую работу с контекстом оборачиваем в блоки myMOC.perFormBlockAndWait - ...; perform - ... (один синк другой эсинк)


Сохранение объектов в приватКонтексте, а объекты вычитываемые для ui в мейнКонтексте

Инициализация стека для кордаты, три контекста (мастер, мейн, сейв - верхний), координатор, модель и стор










